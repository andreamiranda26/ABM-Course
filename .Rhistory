for(p in 1:nrow(parameters)){
setwd("~/GitHub/ABM_Course/")
directory = getwd()
landscape = 100
numindiv= 50  #start off with a number of individuals
numsteps= 10
numreps= 5
move = 10
parameters= expand.grid(landscape,numindiv,numsteps,move) #this creates data frame for combination of variables
for(p in 1:nrow(parameters)){
numindiv = parameters$numindiv[p]
nsteps    = parameters$nsteps[p]
move      = parameters$move[p]
#initialize landscape and adding individuals
pop = NewPop(numindiv, landscape)
pop= createpop(numindiv)
land= landscapeInit(landscape,landscape)
image(land)
for(y in 1: )
movepath = MoveIndv(numindiv, land, move, nsteps,landscape)
help(dims)
??dims
help("dim")
movement <- function(inds, xloc = 2, yloc = 3, xmax = 8, ymax = 8){
total_inds   <- dim(inds)[1]; # Get the number of individuals in inds
move_dists   <- c(-1, 0, 1);  # Define the possible distances to move
x_move       <- sample(x = move_dists, size = total_inds, replace = TRUE);
y_move       <- sample(x = move_dists, size = total_inds, replace = TRUE);
inds[, xloc] <- inds[, xloc] + x_move;
inds[, yloc] <- inds[, yloc] + y_move;
# =========   The reflecting boundary is added below
for(i in 1:total_inds){           # For each individual i in the array
if(inds[i, xloc] > xmax){       # If it moved passed the maximum xloc
inds[i, xloc] <- xmax - 1;    # Then move it back toward the center
}
if(inds[i, xloc] < 1){          # If it moved below 1 on xloc
inds[i, xloc] <- 2;           # Move it toward the centre (2)
}
if(inds[i, yloc] > ymax){         # If it moved passed the maximum yloc
inds[i, yloc] <- ymax - 1;      # Then move it back toward the centre
}
if(inds[i, yloc] < 1){            # If it moved below 1 on yloc
inds[i, yloc] <- 2;             # Then move it toward the centre (2)
}
}
return(inds);
help("function")
help("function")
