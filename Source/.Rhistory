(confint(results[,2])-confint(results[,1]))/2
(confint(results)[,2]-confint(results)[,1])/2
datum=read.csv(file.choose())
head(datum)
###Plot the data using a scatter plot matrix (in package lattice)
library(lattice)
splom(~data.frame(BodyLength,Mass, HFL, Ear),data=datum,groups=Animal)
### run a multivariate analysis of variance (MANOVA)
datum$Animal=factor(datum$Animal) ###Taxon is a number, be sure to tell R that it's a group variable
results=manova(cbind(BodyLength,Mass, HFL, Ear)~Animal,data=datum) ### Run a MANOVA on differences between taxon for the
### three dependent variables
summary(results) ### There are some differences among taxa within the three measures
summary.aov(results) ### Examine which measures are different among taxa
###Part 2
library(MASS)
datum=read.csv(file.choose())
head(datum)
###Plot the data using a scatter plot matrix (in package lattice)
library(lattice)
splom(~data.frame(BodyLength,Mass, HFL, Ear),data=datum,groups=Animal)
### run a multivariate analysis of variance (MANOVA)
datum$Animal=factor(datum$Animal) ###Taxon is a number, be sure to tell R that it's a group variable
results=manova(cbind(BodyLength,Mass, HFL, Ear)~Animal,data=datum) ### Run a MANOVA on differences between taxon for the
### three dependent variables
summary(results) ### There are some differences among taxa within the three measures
summary.aov(results) ### Examine which measures are different among taxa
### run the DFA
results=lda(Animal~BodyLength+Mass+HFL+Ear,data=datum)
### no summary on lda, just call 'results'
results
predict(results)
table(datum$Animal,predict(results)$class)
4/149
### plot the groups against discriminants
plot(results) ### Notice that don't really need second DFA
### run the DFA
results=lda(Animal~BodyLength+Mass+HFL+Ear,data=datum)
### no summary on lda, just call 'results'
results
predict(results)
table(datum$Animal,predict(results)$class)
### run the DFA
results2=lda(Animal~BodyLength+Mass+HFL+Ear,data=datum)
### no summary on lda, just call 'results'
results2
### plot the groups against discriminants
plot(results2) ### Notice that don't really need second DFA
datum=read.csv(file.choose())
resultslm=lm(datum$Predation~results$scores[,1]+results$scores[,2]+results$scores[,3]+results$scores[,4])
summary(resultslm)
library(boot)
### step 1 - import the data
#insert code here to import data
datum=read.csv(file.choose())
head(datum)
parInit=list(a=1,b=1) #this is a list of starting values
CoyoteResults=nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
LynxResults=nls(LynxKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
summary(CoyoteResults)
summary(LynxResults)
library(boot)
### step 1 - import the data
#insert code here to import data
datum=read.csv(file.choose())
head(datum)
parInit=list(a=1,b=1) #this is a list of starting values
CoyoteResults=nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
LynxResults=nls(LynxKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
summary(CoyoteResults)
summary(LynxResults)
### calculate the estimated difference in the asymptotes
CoyoteA=summary(CoyoteResults)$parameters[1] #extracts the value of a from the coyote regression
LynxA=summary(LynxResults)$parameters[1] #extracts the value of a from the lynx regression
Difference=LynxA-CoyoteA #calculates the difference in asymptotes
Difference ### reports the difference in asymptotes
bootFunc=function(bootData,repeats){
results=mean(bootData[repeats,])
return(results)
}
results1= boot(datum,meanFunc, R=1000) ##bootstrap give it the data with the function, takes datum replicates it 1000 times and put replicates in giant matrix and give info to mean func function. takes thes in a matrixs will
meanFunc=function(bootData,repeats){
results=mean(bootData[repeats,])
return(results)
}
results1= boot(datum,meanFunc, R=1000) ##bootstrap give it the data with the function, takes datum replicates it 1000 times and put replicates in giant matrix and give info to mean func function. takes thes in a matrixs will
warnings()
results1
### step 3 and 4 - write a function to resample and reanalyze the data
#insert code to complete "bootFunc" below.
#Note that you can basically copy and past step 2 into bootFunc
#although it will requires some modification to work correctly
repeats=c(1:1000)
meanFunc=function(bootData,repeats){
results=mean(bootData[repeats,])
return(results)
}
results1= boot(datum,meanFunc, R=1000) ##bootstrap give it the data with the function, takes datum replicates it 1000 times and put replicates in giant matrix and give info to mean func function. takes thes in a matrixs will
results1
set.seed(123) #Be sure you run this code before you run the bootstrap
### Step 5 - repeat function 1000 times
### create a bootstrapped object that runs the function 1000 times
#insert code to run bootstrap analysis
set.seed(123) #Be sure you run this code before you run the bootstrap
results1= boot(datum,meanFunc, R=1000) ##bootstrap give it the data with the function, takes datum replicates it 1000 times and put replicates in giant matrix and give info to mean func function. takes thes in a matrixs will
results1
library(boot)
### step 1 - import the data
#insert code here to import data
datum=read.csv(file.choose())
head(datum)
parInit=list(a=1,b=1) #this is a list of starting values
CoyoteResults=nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
LynxResults=nls(LynxKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
summary(CoyoteResults)
summary(LynxResults)
### calculate the estimated difference in the asymptotes
CoyoteA=summary(CoyoteResults)$parameters[1] #extracts the value of a from the coyote regression
LynxA=summary(LynxResults)$parameters[1] #extracts the value of a from the lynx regression
Difference=LynxA-CoyoteA #calculates the difference in asymptotes
Difference ### reports the difference in asymptotes
### step 3 and 4 - write a function to resample and reanalyze the data
#insert code to complete "bootFunc" below.
#Note that you can basically copy and past step 2 into bootFunc
#although it will requires some modification to work correctly
repeats=c(1:1000)
meanFunc=function(bootData,repeats){
results=mean(bootData[repeats,])
return(results)
}
### Step 5 - repeat function 1000 times
### create a bootstrapped object that runs the function 1000 times
#insert code to run bootstrap analysis
set.seed(123) #Be sure you run this code before you run the bootstrap
results1= boot(datum,meanFunc, R=1000) ##bootstrap give it the data with the function, takes datum replicates it 1000 times and put replicates in giant matrix and give info to mean func function. takes thes in a matrixs will
results1
library(boot)
### step 1 - import the data
#insert code here to import data
datum=read.csv(file.choose())
head(datum)
parInit=list(a=1,b=1) #this is a list of starting values
CoyoteResults=nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
LynxResults=nls(LynxKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
summary(CoyoteResults)
### step 1 - import the data
#insert code here to import data
datum=read.csv(file.choose())
head(datum)
parInit=list(a=1,b=1) #this is a list of starting values
CoyoteResults=nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
LynxResults=nls(LynxKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
summary(CoyoteResults)
summary(LynxResults)
### calculate the estimated difference in the asymptotes
CoyoteA=summary(CoyoteResults)$parameters[1] #extracts the value of a from the coyote regression
LynxA=summary(LynxResults)$parameters[1] #extracts the value of a from the lynx regression
Difference=LynxA-CoyoteA #calculates the difference in asymptotes
Difference ### reports the difference in asymptotes
### calculate the estimated difference in the asymptotes
CoyoteA=summary(CoyoteResults)$parameters[1] #extracts the value of a from the coyote regression
LynxA=summary(LynxResults)$parameters[1] #extracts the value of a from the lynx regression
Difference=LynxA-CoyoteA #calculates the difference in asymptotes
Difference ### reports the difference in asymptotes
meanFunc=function(bootData,repeats){
results1= nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=bootData[repeats,])
results2=nls(LynxKill~a*PreyDens/(b+PreyDens),data=bootData[repeats,])
beta=coef(results)[2]
return(beta)
}
library(boot)
### step 1 - import the data
#insert code here to import data
datum=read.csv(file.choose())
head(datum)
parInit=list(a=1,b=1) #this is a list of starting values
CoyoteResults=nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
LynxResults=nls(LynxKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
summary(CoyoteResults)
summary(LynxResults)
### calculate the estimated difference in the asymptotes
CoyoteA=summary(CoyoteResults)$parameters[1] #extracts the value of a from the coyote regression
LynxA=summary(LynxResults)$parameters[1] #extracts the value of a from the lynx regression
Difference=LynxA-CoyoteA #calculates the difference in asymptotes
Difference ### reports the difference in asymptotes
meanFunc=function(bootData,repeats){
results1= nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=bootData[repeats,])
results2=nls(LynxKill~a*PreyDens/(b+PreyDens),data=bootData[repeats,])
beta=coef(results)[2]
return(beta)
}
### Step 5 - repeat function 1000 times
### create a bootstrapped object that runs the function 1000 times
#insert code to run bootstrap analysis
set.seed(123) #Be sure you run this code before you run the bootstrap
boot.results=boot(datum,meanFunc, R=1000)
boot.results=boot(datum,meanFunc, R=1000)
library(boot)
### step 1 - import the data
#insert code here to import data
datum=read.csv(file.choose())
library(boot)
### step 1 - import the data
#insert code here to import data
datum=read.csv(file.choose())
head(datum)
parInit=list(a=1,b=1) #this is a list of starting values
CoyoteResults=nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
LynxResults=nls(LynxKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
summary(CoyoteResults)
summary(LynxResults)
### calculate the estimated difference in the asymptotes
CoyoteA=summary(CoyoteResults)$parameters[1] #extracts the value of a from the coyote regression
LynxA=summary(LynxResults)$parameters[1] #extracts the value of a from the lynx regression
Difference=LynxA-CoyoteA #calculates the difference in asymptotes
Difference ### reports the difference in asymptotes
bootFunc=function(bootData,repeats){
parInit=list(a=1, b=1)
CoyoteResults= nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=bootData[repeats,], start= parInit)
LynxResults=nls(LynxKill~a*PreyDens/(b+PreyDens),data=bootData[repeats,], start= parInit)
#treat similar as above data
CoyoteA=summary(CoyoteResults)$parameters[1]
LynxA=summary(CoyoteResults)$parameters[1]
Difference=LynxA-CoyoteA
return(Difference) #repeating difference and returning the repeated difference
}
set.seed(123) #Be sure you run this code before you run the bootstrap
boot.results=boot(datum,meanFunc, R=1000)
boot.results
set.seed(123) #Be sure you run this code before you run the bootstrap
boot.results=boot(datum,bootFunc, R=1000)
boot.results
boot.ci(boot.results)
### step 1 - import the data
#insert code here to import data
datum=read.csv(file.choose())
head(datum)
parInit=list(a=1,b=1) #this is a list of starting values
CoyoteResults=nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
LynxResults=nls(LynxKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
summary(CoyoteResults)
summary(LynxResults)
### calculate the estimated difference in the asymptotes
CoyoteA=summary(CoyoteResults)$parameters[1] #extracts the value of a from the coyote regression
LynxA=summary(LynxResults)$parameters[1] #extracts the value of a from the lynx regression
Difference=LynxA-CoyoteA #calculates the difference in asymptotes
Difference ### reports the difference in asymptotes
bootFunc=function(bootData,repeats){
parInit=list(a=1, b=1)
CoyoteResults= nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=bootData[repeats,], start= parInit)
LynxResults=nls(LynxKill~a*PreyDens/(b+PreyDens),data=bootData[repeats,], start= parInit)
#treat similar as above data
CoyoteA=summary(CoyoteResults)$parameters[1]
LynxA=summary(CoyoteResults)$parameters[1]
Difference=LynxA-CoyoteA
return(Difference) #repeating difference and returning the repeated difference
}
set.seed(123) #Be sure you run this code before you run the bootstrap
boot.results=boot(datum,bootFunc, R=1000)
boot.results
boot.ci(boot.results)
sort(boot.results$t)
plot(boot.results)
set.seed(123) #Be sure you run this code before you run the bootstrap
boot.results=boot(datum,bootFunc, R=1000)
boot.results
library(boot)
### step 1 - import the data
#insert code here to import data
datum=read.csv(file.choose())
head(datum)
parInit=list(a=1,b=1) #this is a list of starting values
CoyoteResults=nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
LynxResults=nls(LynxKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
summary(CoyoteResults)
summary(LynxResults)
### calculate the estimated difference in the asymptotes
CoyoteA=summary(CoyoteResults)$parameters[1] #extracts the value of a from the coyote regression
LynxA=summary(LynxResults)$parameters[1] #extracts the value of a from the lynx regression
Difference=LynxA-CoyoteA #calculates the difference in asymptotes
Difference ### reports the difference in asymptotes
bootFunc=function(bootData,repeats){
parInit=list(a=1, b=1)
CoyoteResults= nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=bootData[repeats,], start= parInit)
LynxResults=nls(LynxKill~a*PreyDens/(b+PreyDens),data=bootData[repeats,], start= parInit)
#treat similar as above data
CoyoteA=summary(CoyoteResults)$parameters[1]
LynxA=summary(CoyoteResults)$parameters[1]
Difference=LynxA-CoyoteA
return(Difference) #repeating difference and returning the repeated difference
}
set.seed(123) #Be sure you run this code before you run the bootstrap
boot.results=boot(datum,bootFunc, R=1000)
boot.results
boot.ci(boot.results)
bootFunc=function(bootData,repeats){
parInit=list(a=1,b=1)
CoyoteResults=nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=bootData[repeats,],start=parInit)
#need to analyze boot data and will need to splice
LynxResults=nls(LynxKill~a*PreyDens/(b+PreyDens),data=bootData[repeats,],start=parInit)
#treat similar to above data
CoyoteA=summary(CoyoteResults)$parameters[1]
LynxA=summary(LynxResults)$parameters[1]
Difference=LynxA-CoyoteA
return(Difference)#repeating difference and returning the repeated difference
}
set.seed(123) #Be sure you run this code before you run the bootstrap
boot.results=boot(datum,bootFunc, R=1000)
boot.results
boot.ci(boot.results)
sort(boot.results$t)
plot(boot.results)
boot.ci(boot.results)
library(boot)
### step 1 - import the data
#insert code here to import data
datum=read.csv(file.choose())
head(datum)
parInit=list(a=1,b=1) #this is a list of starting values
CoyoteResults=nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
LynxResults=nls(LynxKill~a*PreyDens/(b+PreyDens),data=datum,start=parInit)
summary(CoyoteResults)
summary(LynxResults)
### calculate the estimated difference in the asymptotes
CoyoteA=summary(CoyoteResults)$parameters[1] #extracts the value of a from the coyote regression
LynxA=summary(LynxResults)$parameters[1] #extracts the value of a from the lynx regression
Difference=LynxA-CoyoteA #calculates the difference in asymptotes
Difference ### reports the difference in asymptotes
bootFunc=function(bootData,repeats){
parInit=list(a=1,b=1)
CoyoteResults=nls(CoyoteKill~a*PreyDens/(b+PreyDens),data=bootData[repeats,],start=parInit)
#need to analyze boot data and will need to splice
LynxResults=nls(LynxKill~a*PreyDens/(b+PreyDens),data=bootData[repeats,],start=parInit)
#treat similar to above data
CoyoteA=summary(CoyoteResults)$parameters[1]
LynxA=summary(LynxResults)$parameters[1]
Difference=LynxA-CoyoteA
return(Difference)#repeating difference and returning the repeated difference
}
set.seed(123) #Be sure you run this code before you run the bootstrap
boot.results=boot(datum,bootFunc, R=1000)
boot.results
boot.ci(boot.results)
sort(boot.results$t)
plot(boot.results)
help(==)
==
??==
Move=function(landscape,numindiv,numsteps,move,numcamera){
mvmt = numindiv[1] #x==1, y==2
for(s in 1:numsteps){
cxpos = mvmt[(length(mvmt)-1)]
cypos = mvmt[length(mvmt)]
#determine if indiv will move randomly or will move to next cell
movenext = sample(x=c(0,1), size=1, prob=c((1-move), move))
#random movement to adjacent cell/patch
if(movenext==0){
xpos = sample(c(-1,0,1), 1) + cxpos
ypos = sample(c(-1,0,1), 1) + cypos
}
#move to next cell if
if(movehigh==1){
#find next cell
nxtcell = which(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)] == max(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)]), arr.ind = TRUE)
#calculate new position (x and y values)
if(nxtcell[1]==1){xpos = cxpos - 1 }
if(nxtcell[1]==2){xpos = cxpos }
if(nxtcell[1]==3){xpos = cxpos + 1 }
if(nxtcell[2]==1){ypos = cypos - 1 }
if(nxtcell[2]==2){ypos = cypos }
if(nxtcell[2]==3){ypos = cypos + 1 }
#record new position
mvmt = c(mvmt, xpos, ypos)
#check to see if individual is at peak; if yes individual remains in same position
##if(land[xpos,ypos]>=landscape[2]){
#fill out remaining positions
#mvmt=c(mvmt, rep(c(xpos, ypos), (nsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
#check to see if individual is at edge of landscape; if yes individual remains in same position
if(xpos>=(landscape-1) | ypos>=(landscape-1) | xpos<=1 | ypos<=1){
#fill out remaining positions
mvmt=c(mvmt, rep(c(xpos, ypos), (numsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
}
return(mvmt)
}
LandscapeInit = function(landscape){
#set up object
land  = matrix(nrow=landscape, ncol=landscape)
#work from edges and fill in elevation; similar to above but can now do entire columns at one time
#for(r in (xpeak-1):1){
# land[r,] = land[(r+1),] - round(rnorm(landscape, 5, 2), 0)
# }
# for(r in (xpeak+1):landscape){
#  land[r,] = land[(r-1),] - round(rnorm(landscape, 5, 2), 0)
#}
#return land object
return(land)
}
Pop = function(numindiv, landscape){
#how far apart should individuals be, at max?
variance = 25 #values is in cells
#initialize pop object
pop = matrix(nrow=100, ncol=100)
#choose rough starting coordinates
x = sample(1:(landscape-variance), 1)
y = sample(1:(landscape-variance), 1)
#set starting locations with set variance from x,y selected above
pop[,1]  = x + rnorm(numindiv, variance)
pop[,2]  = y + rnorm(numindiv, variance)
return(pop)
}
#Set working directory, import packages, source functions,
setwd("~/GitHub/ABM-Course/Source")    # set temp working directory
#source functions
source(paste(getwd(), "/Landscape.R", sep = ''))
source(paste(getwd(), "/POP.R", sep = ''))
source(paste(getwd(), "/Move.R", sep = ''))
setwd("~/GitHub/ABM-Course")
#to make sure it is the right place you should do session then set up working directory
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
landscape = 100
numindiv= 10  #start off with a number of individuals
numsteps= 1 #number of steps individuals will take
numreps= 5  #
move = 5   #Likelihood of individuals moving to the next cell
numcamera = 50
parameters= expand.grid(landscape,numindiv,numsteps,move,numcamera) #this creates data frame for combination of variables
colnames(parameters) = c("landscape","numindiv","numsteps","move","numcamera")
for(p in 1:nrow(parameters)){
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
numsteps    = parameters$numsteps[p]
move      = parameters$move[p]
numcamera = parameters$numcamera[p]
#initialize individuals on landscape
pop = Pop(numindiv, landscape)
#points(Pop[,1]/100, Pop[,2]/100, pch=21, cex=0.5)
#pop = rbind(pop,NewPop(nindv,landscape)) #this will add the different NewPops together
#plot(-100,-100, xlim=c(0,100), ylim=c(0,100))  #this puts the points on its own figure (note 0-100 axes)
#points(pop[,1], pop[,2], pch=19, cex=0.5) #puts points on own fig
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
numindiv = pop[i,,drop=FALSE]
#the i means iterates
#####     #chart movement
movepath = Move(landscape,numindiv,numsteps,move,numcamera)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/100, movepath[seq(2,length(movepath), 2)]/100, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
}
pop = Pop(numindiv, landscape)
points(Pop[,1]/100, Pop[,2]/100, pch=21, cex=0.5)
pop
Pop = function(numindiv, landscape){
#how far apart should individuals be, at max?
variance = 25 #values is in cells
#initialize pop object
pop = matrix(nrow=100, ncol=100)
#choose rough starting coordinates
x = sample(1:(landscape-variance), 1)
y = sample(1:(landscape-variance), 1)
#set starting locations with set variance from x,y selected above
pop[,1]  = x + dpois(numindiv, variance)
pop[,2]  = y + dpois(numindiv, variance)
return(pop)
}
setwd("~/GitHub/ABM-Course")
#to make sure it is the right place you should do session then set up working directory
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
landscape = 100
numindiv= 10  #start off with a number of individuals
numsteps= 1 #number of steps individuals will take
numreps= 5  #
move = 5   #Likelihood of individuals moving to the next cell
numcamera = 50
parameters= expand.grid(landscape,numindiv,numsteps,move,numcamera) #this creates data frame for combination of variables
colnames(parameters) = c("landscape","numindiv","numsteps","move","numcamera")
for(p in 1:nrow(parameters)){
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
numsteps    = parameters$numsteps[p]
move      = parameters$move[p]
numcamera = parameters$numcamera[p]
pop = Pop(numindiv, landscape)
points(Pop[,1]/100, Pop[,2]/100, pch=21, cex=0.5)
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
numindiv = pop[i,,drop=FALSE]
#the i means iterates
#####     #chart movement
movepath = Move(landscape,numindiv,numsteps,move,numcamera)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/100, movepath[seq(2,length(movepath), 2)]/100, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
xcol
xcol
