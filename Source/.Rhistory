cypos = mvmt[length(mvmt)]
#determine if indiv will move randomly or will move to next cell
movehigh = sample(x=c(0,1), size=1, prob=c((1-move), move))
#random movement to adjacent cell/patch
if(movehigh==0){
xpos = sample(c(-1,0,1), 1) + cxpos
ypos = sample(c(-1,0,1), 1) + cypos
}
#move to higher elevation, added the 'else' here instead of 'if'
if(movehigh==1){
#find highest elevation cell
highpt = which(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)] == max(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)]), arr.ind = TRUE)
#calculate new position (x and y values)
if(highpt[1]==1){xpos = cxpos - 1 }
if(highpt[1]==2){xpos = cxpos }
if(highpt[1]==3){xpos = cxpos + 1 }
if(highpt[2]==1){ypos = cypos - 1 }
if(highpt[2]==2){ypos = cypos }
if(highpt[2]==3){ypos = cypos + 1 }
}
#record new position
mvmt = c(mvmt, xpos, ypos)
#check to see if individual is at peak; if yes individual remains in same position
if(land[xpos,ypos]>=elevation[2]){
#fill out remaining positions
mvmt=c(mvmt, rep(c(xpos, ypos), (nsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
#check to see if individual is at edge of landscape; if yes individual remains in same position
if(xpos>=(landscape-1) | ypos>=(landscape-1) | xpos<=1 | ypos<=1){
#fill out remaining positions
mvmt=c(mvmt, rep(c(xpos, ypos), (nsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
}
return(mvmt)
}
LandscapeInit = function(landscape){
#set up object
land  = matrix(nrow=landscape, ncol=landscape)
#work from edges and fill in elevation; similar to above but can now do entire columns at one time
#for(r in (xpeak-1):1){
# land[r,] = land[(r+1),] - round(rnorm(landscape, 5, 2), 0)
# }
# for(r in (xpeak+1):landscape){
#  land[r,] = land[(r-1),] - round(rnorm(landscape, 5, 2), 0)
#}
#return land object
return(land)
}
setwd("~/GitHub/ABM_Course/")
#to make sure it is the right place you should do session then set up working directory
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
setwd("~/GitHub/ABM_Course/Source")
setwd("~/GitHub/ABM-Course")
setwd("~/GitHub/ABM_Course/Source")
setwd("~/GitHub/ABM-Course/Source")
setwd("~/GitHub/ABM-Course/Source")
#to make sure it is the right place you should do session then set up working directory
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
landscape = 100
numindiv= 1  #start off with a number of individuals
numsteps= 1 #number of steps individuals will take
numreps= 5  #
move = 10   #Likelihood of individuals moving to the next cell
numcamera = 50
parameters= expand.grid(landscape,numindiv,numsteps,move,numcamera) #this creates data frame for combination of variables
for(p in 1:nrow(parameters)){
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
nsteps    = parameters$nsteps[p]
move      = parameters$move[p]
numcamera = parameters$numcamera[p]
#initialize individuals on landscape
pop = NPop(nindvs, landscape)
points(pop[,1]/100, pop[,2]/100, pch=21, cex=0.5)
#pop = rbind(pop,NewPop(nindv,landscape)) #this will add the different NewPops together
#plot(-100,-100, xlim=c(0,150), ylim=c(0,150))  #this puts the points on its own figure (note 0-150 axes)
#points(pop[,1], pop[,2], pch=19, cex=0.5) #puts points on own fig
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#the i means iterates
#chart movement
movepath = MoveIndv(numind, land, move, nsteps, elevation, landscape)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
rownames(pathways) = seq(1,nindvs,1)
dev.copy(png, "../output/Butter.png") #saves it to the source folder that you had everything, albeit adding 'output' saves it in the output folder
dev.off() #need to add this if not it will not save, if you do the pdf code at the top and close it off then you can open it and see even through the steps.
#extract needed output from simulation
#for this project it is fine to NOT do any stats, but you will want to export something (maybe a figure) so you and
#everyone can see how your model worked. we will use this to talk about approaches that worked well/did not work great.
}
pop = pop(numindiv, landscape)
pop = Pop(numindiv, landscape)
for(p in 1:nrow(parameters)){
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
nsteps    = parameters$nsteps[p]
move      = parameters$move[p]
numcamera = parameters$numcamera[p]
#initialize individuals on landscape
pop = Pop(numindiv, landscape)
points(pop[,1]/100, pop[,2]/100, pch=21, cex=0.5)
#pop = rbind(pop,NewPop(nindv,landscape)) #this will add the different NewPops together
#plot(-100,-100, xlim=c(0,150), ylim=c(0,150))  #this puts the points on its own figure (note 0-150 axes)
#points(pop[,1], pop[,2], pch=19, cex=0.5) #puts points on own fig
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#the i means iterates
#chart movement
movepath = MoveIndv(numind, land, move, nsteps, elevation, landscape)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
rownames(pathways) = seq(1,nindvs,1)
dev.copy(png, "../output/Butter.png") #saves it to the source folder that you had everything, albeit adding 'output' saves it in the output folder
dev.off() #need to add this if not it will not save, if you do the pdf code at the top and close it off then you can open it and see even through the steps.
#extract needed output from simulation
#for this project it is fine to NOT do any stats, but you will want to export something (maybe a figure) so you and
#everyone can see how your model worked. we will use this to talk about approaches that worked well/did not work great.
}
pop = Pop(numindiv, landscape)
points(Pop[,1]/100, Pop[,2]/100, pch=21, cex=0.5)
pop = Pop(numindiv, landscape)
#initialize pop object
pop = matrix(nrow=numindiv, ncol=10)
#choose rough starting coordinates
x = sample(1:(landscape-variance), 1)
y = sample(1:(landscape-variance), 1)
#set starting locations with set variance from x,y selected above
pop[,1]  = x + poisson(numindiv, variance)
pop[,2]  = y + poisson(numindiv, variance)
return(pop)
Pop = function(numindiv, landscape){
#how far apart should individuals be, at max?
variance = 25 #values is in cells
#initialize pop object
pop = matrix(nrow=numindiv, ncol=10)
#choose rough starting coordinates
x = sample(1:(landscape-variance), 1)
y = sample(1:(landscape-variance), 1)
#set starting locations with set variance from x,y selected above
pop[,1]  = x + poisson(numindiv, variance)
pop[,2]  = y + poisson(numindiv, variance)
return(pop)
}
pop = Pop(numindiv, landscape)
#initialize pop object
pop = matrix(nrow=numindiv, ncol=100)
#choose rough starting coordinates
x = sample(1:(landscape-variance), 1)
Pop = function(numindiv, landscape){
#how far apart should individuals be, at max?
variance = 25 #values is in cells
#initialize pop object
pop = matrix(nrow=100, ncol=100)
#choose rough starting coordinates
x = sample(1:(landscape-variance), 1)
y = sample(1:(landscape-variance), 1)
#set starting locations with set variance from x,y selected above
pop[,1]  = x + poisson(numindiv, variance)
pop[,2]  = y + poisson(numindiv, variance)
return(pop)
}
#initialize pop object
pop = matrix(nrow=100, ncol=100)
pop = Pop(numindiv, landscape)
pop = Pop(numindiv, landscape)
numindiv
p=1
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
nsteps    = parameters$nsteps[p]
move      = parameters$move[p]
pop = Pop(numindiv, landscape)
numindiv
View(parameters)
parameters= expand.grid(landscape,numindiv,numsteps,move,numcamera) #this creates data frame for combination of variables
colnames(parameters) = c("landscape","numindiv","numsteps","move","numcamera")
traceback()
colnames(parameters) = c("landscape","numindiv","numsteps","move","numcamera")
colnames(parameters) = c("landscape","numindiv","numsteps","move","numcamera")
head(parameters)
landscape = 100
numindiv= 1  #start off with a number of individuals
numsteps= 1 #number of steps individuals will take
numreps= 5  #
move = 10   #Likelihood of individuals moving to the next cell
numcamera = 50
parameters= expand.grid(landscape,numindiv,numsteps,move,numcamera) #this creates data frame for combination of variables
parameters
colnames(parameters) = c("landscape","numindiv","numsteps","move","numcamera")
p=1
for(p in 1:nrow(parameters)){
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
nsteps    = parameters$nsteps[p]
move      = parameters$move[p]
numcamera = parameters$numcamera[p]
#initialize individuals on landscape
pop = Pop(numindiv, landscape)
points(Pop[,1]/100, Pop[,2]/100, pch=21, cex=0.5)
#pop = rbind(pop,NewPop(nindv,landscape)) #this will add the different NewPops together
#plot(-100,-100, xlim=c(0,100), ylim=c(0,100))  #this puts the points on its own figure (note 0-100 axes)
#points(pop[,1], pop[,2], pch=19, cex=0.5) #puts points on own fig
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#the i means iterates
#chart movement
movepath = MoveIndv(numind, land, move, nsteps, elevation, landscape)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
rownames(pathways) = seq(1,nindvs,1)
dev.copy(png, "../output/Butter.png") #saves it to the source folder that you had everything, albeit adding 'output' saves it in the output folder
dev.off() #need to add this if not it will not save, if you do the pdf code at the top and close it off then you can open it and see even through the steps.
#extract needed output from simulation
#for this project it is fine to NOT do any stats, but you will want to export something (maybe a figure) so you and
#everyone can see how your model worked. we will use this to talk about approaches that worked well/did not work great.
}
Pop = function(numindiv, landscape){
#how far apart should individuals be, at max?
variance = 25 #values is in cells
#initialize pop object
pop = matrix(nrow=100, ncol=100)
#choose rough starting coordinates
x = sample(1:(landscape-variance), 1)
y = sample(1:(landscape-variance), 1)
#set starting locations with set variance from x,y selected above
pop[,1]  = x + rnorm(numindiv, variance)
pop[,2]  = y + rnorm(numindiv, variance)
return(pop)
}
landscape = 100
numindiv= 1  #start off with a number of individuals
numsteps= 1 #number of steps individuals will take
numreps= 5  #
move = 10   #Likelihood of individuals moving to the next cell
numcamera = 50
parameters= expand.grid(landscape,numindiv,numsteps,move,numcamera) #this creates data frame for combination of variables
colnames(parameters) = c("landscape","numindiv","numsteps","move","numcamera")
p=1
for(p in 1:nrow(parameters)){
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
nsteps    = parameters$nsteps[p]
move      = parameters$move[p]
numcamera = parameters$numcamera[p]
#initialize individuals on landscape
pop = Pop(numindiv, landscape)
points(Pop[,1]/100, Pop[,2]/100, pch=21, cex=0.5)
#pop = rbind(pop,NewPop(nindv,landscape)) #this will add the different NewPops together
#plot(-100,-100, xlim=c(0,100), ylim=c(0,100))  #this puts the points on its own figure (note 0-100 axes)
#points(pop[,1], pop[,2], pch=19, cex=0.5) #puts points on own fig
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#the i means iterates
#chart movement
movepath = MoveIndv(numind, land, move, nsteps, elevation, landscape)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
rownames(pathways) = seq(1,nindvs,1)
dev.copy(png, "../output/Butter.png") #saves it to the source folder that you had everything, albeit adding 'output' saves it in the output folder
dev.off() #need to add this if not it will not save, if you do the pdf code at the top and close it off then you can open it and see even through the steps.
#extract needed output from simulation
#for this project it is fine to NOT do any stats, but you will want to export something (maybe a figure) so you and
#everyone can see how your model worked. we will use this to talk about approaches that worked well/did not work great.
}
}
landscape = 100
numindiv= 1  #start off with a number of individuals
numsteps= 1 #number of steps individuals will take
numreps= 5  #
move = 10   #Likelihood of individuals moving to the next cell
numcamera = 50
parameters= expand.grid(landscape,numindiv,numsteps,move,numcamera) #this creates data frame for combination of variables
colnames(parameters) = c("landscape","numindiv","numsteps","move","numcamera")
p=1
for(p in 1:nrow(parameters)){
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
nsteps    = parameters$nsteps[p]
move      = parameters$move[p]
numcamera = parameters$numcamera[p]
#initialize individuals on landscape
pop = Pop(numindiv, landscape)
#points(Pop[,1]/100, Pop[,2]/100, pch=21, cex=0.5)
#pop = rbind(pop,NewPop(nindv,landscape)) #this will add the different NewPops together
#plot(-100,-100, xlim=c(0,100), ylim=c(0,100))  #this puts the points on its own figure (note 0-100 axes)
#points(pop[,1], pop[,2], pch=19, cex=0.5) #puts points on own fig
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#the i means iterates
#chart movement
movepath = MoveIndv(numind, land, move, nsteps, elevation, landscape)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
rownames(pathways) = seq(1,nindvs,1)
dev.copy(png, "../output/Butter.png") #saves it to the source folder that you had everything, albeit adding 'output' saves it in the output folder
dev.off() #need to add this if not it will not save, if you do the pdf code at the top and close it off then you can open it and see even through the steps.
#extract needed output from simulation
#for this project it is fine to NOT do any stats, but you will want to export something (maybe a figure) so you and
#everyone can see how your model worked. we will use this to talk about approaches that worked well/did not work great.
}
#####     #chart movement
movepath = MoveIndv(landscape,numindiv,numsteps,move,numcamera)
Pop = function(numindiv, landscape){
#how far apart should individuals be, at max?
variance = 25 #values is in cells
#initialize pop object
pop = matrix(nrow=100, ncol=100)
#choose rough starting coordinates
x = sample(1:(landscape-variance), 1)
y = sample(1:(landscape-variance), 1)
#set starting locations with set variance from x,y selected above
pop[,1]  = x + rnorm(numindiv, variance)
pop[,2]  = y + rnorm(numindiv, variance)
return(pop)
}
Move=function(landscape,numindiv,numsteps,move,numcamera){
mvmt = numindiv[1,1:2] #x==1, y==2
for(s in 1:nsteps){
cxpos = mvmt[(length(mvmt)-1)]
cypos = mvmt[length(mvmt)]
#determine if indiv will move randomly or will move to next cell
movehigh = sample(x=c(0,1), size=1, prob=c((1-move), move))
#random movement to adjacent cell/patch
if(movehigh==0){
xpos = sample(c(-1,0,1), 1) + cxpos
ypos = sample(c(-1,0,1), 1) + cypos
}
#move to higher elevation, added the 'else' here instead of 'if'
if(movehigh==1){
#find highest elevation cell
highpt = which(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)] == max(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)]), arr.ind = TRUE)
#calculate new position (x and y values)
if(highpt[1]==1){xpos = cxpos - 1 }
if(highpt[1]==2){xpos = cxpos }
if(highpt[1]==3){xpos = cxpos + 1 }
if(highpt[2]==1){ypos = cypos - 1 }
if(highpt[2]==2){ypos = cypos }
if(highpt[2]==3){ypos = cypos + 1 }
}
#record new position
mvmt = c(mvmt, xpos, ypos)
#check to see if individual is at peak; if yes individual remains in same position
if(land[xpos,ypos]>=elevation[2]){
#fill out remaining positions
mvmt=c(mvmt, rep(c(xpos, ypos), (nsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
#check to see if individual is at edge of landscape; if yes individual remains in same position
if(xpos>=(landscape-1) | ypos>=(landscape-1) | xpos<=1 | ypos<=1){
#fill out remaining positions
mvmt=c(mvmt, rep(c(xpos, ypos), (nsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
}
return(mvmt)
}
LandscapeInit = function(landscape){
#set up object
land  = matrix(nrow=landscape, ncol=landscape)
#work from edges and fill in elevation; similar to above but can now do entire columns at one time
#for(r in (xpeak-1):1){
# land[r,] = land[(r+1),] - round(rnorm(landscape, 5, 2), 0)
# }
# for(r in (xpeak+1):landscape){
#  land[r,] = land[(r-1),] - round(rnorm(landscape, 5, 2), 0)
#}
#return land object
return(land)
}
#Set working directory, import packages, source functions,
setwd("~/GitHub/ABM-Course/Source")    # set temp working directory
#source functions
source(paste(getwd(), "/Landscape.R", sep = ''))
source(paste(getwd(), "/POP.R", sep = ''))
source(paste(getwd(), "/Move.R", sep = ''))
setwd("~/GitHub/ABM-Course/Source")
#to make sure it is the right place you should do session then set up working directory
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
#Set working directory, import packages, source functions,
setwd("~/GitHub/ABM-Course/Source")    # set temp working directory
#source functions
source(paste(getwd(), "/Landscape.R", sep = ''))
source(paste(getwd(), "/POP.R", sep = ''))
source(paste(getwd(), "/Move.R", sep = ''))
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
#Set working directory, import packages, source functions,
setwd("~/GitHub/ABM-Course/Source")    # set temp working directory
#source functions
source(paste(getwd(), "/Landscape.R", sep = ''))
source(paste(getwd(), "/POP.R", sep = ''))
source(paste(getwd(), "/Move.R", sep = ''))
LandscapeInit = function(landscape){
#set up object
land  = matrix(nrow=landscape, ncol=landscape)
#work from edges and fill in elevation; similar to above but can now do entire columns at one time
#for(r in (xpeak-1):1){
# land[r,] = land[(r+1),] - round(rnorm(landscape, 5, 2), 0)
# }
# for(r in (xpeak+1):landscape){
#  land[r,] = land[(r-1),] - round(rnorm(landscape, 5, 2), 0)
#}
#return land object
return(land)
}
Move=function(landscape,numindiv,numsteps,move,numcamera){
mvmt = numindiv[1,1:2] #x==1, y==2
for(s in 1:nsteps){
cxpos = mvmt[(length(mvmt)-1)]
cypos = mvmt[length(mvmt)]
#determine if indiv will move randomly or will move to next cell
movehigh = sample(x=c(0,1), size=1, prob=c((1-move), move))
#random movement to adjacent cell/patch
if(movehigh==0){
xpos = sample(c(-1,0,1), 1) + cxpos
ypos = sample(c(-1,0,1), 1) + cypos
}
#move to higher elevation, added the 'else' here instead of 'if'
if(movehigh==1){
#find highest elevation cell
highpt = which(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)] == max(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)]), arr.ind = TRUE)
#calculate new position (x and y values)
if(highpt[1]==1){xpos = cxpos - 1 }
if(highpt[1]==2){xpos = cxpos }
if(highpt[1]==3){xpos = cxpos + 1 }
if(highpt[2]==1){ypos = cypos - 1 }
if(highpt[2]==2){ypos = cypos }
if(highpt[2]==3){ypos = cypos + 1 }
}
#record new position
mvmt = c(mvmt, xpos, ypos)
#check to see if individual is at peak; if yes individual remains in same position
if(land[xpos,ypos]>=elevation[2]){
#fill out remaining positions
mvmt=c(mvmt, rep(c(xpos, ypos), (nsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
#check to see if individual is at edge of landscape; if yes individual remains in same position
if(xpos>=(landscape-1) | ypos>=(landscape-1) | xpos<=1 | ypos<=1){
#fill out remaining positions
mvmt=c(mvmt, rep(c(xpos, ypos), (nsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
}
return(mvmt)
}
Pop = function(numindiv, landscape){
#how far apart should individuals be, at max?
variance = 25 #values is in cells
#initialize pop object
pop = matrix(nrow=100, ncol=100)
#choose rough starting coordinates
x = sample(1:(landscape-variance), 1)
y = sample(1:(landscape-variance), 1)
#set starting locations with set variance from x,y selected above
pop[,1]  = x + rnorm(numindiv, variance)
pop[,2]  = y + rnorm(numindiv, variance)
return(pop)
}
setwd("~/GitHub/ABM-Course/Source")
#to make sure it is the right place you should do session then set up working directory
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
setwd("~/GitHub/ABM-Course/Source")
#to make sure it is the right place you should do session then set up working directory
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
