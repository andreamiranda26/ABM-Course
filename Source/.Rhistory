[ store somewhere that this individual was captured, ID = pop[m,1]] #store somewhere that this individual was captured,you could do something similar as with CAM, where you initialize an empty object with 'OUT <- NULL' and rbind sub to that object
}
}
}
LandscapeInit = function(landscape){
#set up object
land  = matrix(nrow=landscape, ncol=landscape)
#return land object
return(land)
}
# Record the individuals as captured
Track <- NULL #initialize an empty object with 'CAM <- NULL' and rbind sub to that object
for(m in 1:nrow(pop)){  # the first loop (m in 1:nrow(pop)) loops over each individual in your dataset, and for each individual, the second loop (n in 1:nrow(CAM)) loops over the camera locations stored in CAM to see if any camera locations match the individual's location (the sub <- ... line)
for(n in 1:nrow(CAM)){ #for the number of cameras in a cell
sub <- CAM[CAM[n,2] == pop[m,2] & CAM[n,3] == pop[m,3],]  #to see if any camera locations match the individual's location (the sub <- ... line)
if(nrow(sub) > 0){ #if there's at least one match (nrow(sub) > 0 ), then you can store the information...
ID = pop[m,1] #store somewhere that this individual was captured,you could do something similar as with CAM, where you initialize an empty object with 'OUT <- NULL' and rbind sub to that object
save<- c(c,sub, ID)
Track <- rbind(Track, save)
}
}
}
Pop = function(numindiv, landscape){
#how far apart should individuals be, at max?
variance = 25 #values is in cells
#initialize pop object
pop = matrix(nrow=100, ncol=100)
#choose rough starting coordinates
x = sample(1:(landscape-variance), 1)
y = sample(1:(landscape-variance), 1)
#set starting locations with set variance from x,y selected above
pop[,1]  = x + rpois(numindiv, variance)
pop[,2]  = y + rpois(numindiv, variance)
return(pop)
}
# Record the individuals as captured
Track <- NULL #initialize an empty object with 'CAM <- NULL' and rbind sub to that object
for(m in 1:nrow(pop)){  # the first loop (m in 1:nrow(pop)) loops over each individual in your dataset, and for each individual, the second loop (n in 1:nrow(CAM)) loops over the camera locations stored in CAM to see if any camera locations match the individual's location (the sub <- ... line)
for(n in 1:nrow(CAM)){ #for the number of cameras in a cell
sub <- CAM[CAM[n,2] == pop[m,2] & CAM[n,3] == pop[m,3],]  #to see if any camera locations match the individual's location (the sub <- ... line)
if(nrow(sub) > 0){ #if there's at least one match (nrow(sub) > 0 ), then you can store the information...
ID = pop[m,1] #store somewhere that this individual was captured,you could do something similar as with CAM, where you initialize an empty object with 'OUT <- NULL' and rbind sub to that object
save<- c(c,sub, ID)
Track <- rbind(Track, save)
}
}
}
# Record the individuals as captured
Track <- NULL #initialize an empty object with 'CAM <- NULL' and rbind sub to that object
for(m in 1:nrow(Pop)){  # the first loop (m in 1:nrow(pop)) loops over each individual in your dataset, and for each individual, the second loop (n in 1:nrow(CAM)) loops over the camera locations stored in CAM to see if any camera locations match the individual's location (the sub <- ... line)
for(n in 1:nrow(CAM)){ #for the number of cameras in a cell
sub <- CAM[CAM[n,2] == pop[m,2] & CAM[n,3] == pop[m,3],]  #to see if any camera locations match the individual's location (the sub <- ... line)
if(nrow(sub) > 0){ #if there's at least one match (nrow(sub) > 0 ), then you can store the information...
ID = pop[m,1] #store somewhere that this individual was captured,you could do something similar as with CAM, where you initialize an empty object with 'OUT <- NULL' and rbind sub to that object
save<- c(c,sub, ID)
Track <- rbind(Track, save)
}
}
}
Pop
# Record the individuals as captured
Track <- NULL #initialize an empty object with 'CAM <- NULL' and rbind sub to that object
for(m in 1:nrow(Pop)){  # the first loop (m in 1:nrow(pop)) loops over each individual in your dataset, and for each individual, the second loop (n in 1:nrow(CAM)) loops over the camera locations stored in CAM to see if any camera locations match the individual's location (the sub <- ... line)
for(n in 1:nrow(CAM)){ #for the number of cameras in a cell
sub <- CAM[CAM[n,2] == pop[m,2] & CAM[n,3] == pop[m,3],]  #to see if any camera locations match the individual's location (the sub <- ... line)
if(nrow(sub) > 0){ #if there's at least one match (nrow(sub) > 0 ), then you can store the information...
ID = pop[m,1] #store somewhere that this individual was captured,you could do something similar as with CAM, where you initialize an empty object with 'OUT <- NULL' and rbind sub to that object
save<- c(c,sub, ID)
Track <- rbind(Track, save)
}
}
}
numindiv
landscape
# Record the individuals as captured
Track <- NULL #initialize an empty object with 'CAM <- NULL' and rbind sub to that object
for(m in 1:nrow(Pop)){  # the first loop (m in 1:nrow(pop)) loops over each individual in your dataset, and for each individual, the second loop (n in 1:nrow(CAM)) loops over the camera locations stored in CAM to see if any camera locations match the individual's location (the sub <- ... line)
for(n in 1:nrow(CAM)){ #for the number of cameras in a cell
sub <- CAM[CAM[n,2] == pop[m,2] & CAM[n,3] == pop[m,3],]  #to see if any camera locations match the individual's location (the sub <- ... line)
if(nrow(sub) > 0){ #if there's at least one match (nrow(sub) > 0 ), then you can store the information...
ID = pop[m,1] #store somewhere that this individual was captured,you could do something similar as with CAM, where you initialize an empty object with 'OUT <- NULL' and rbind sub to that object
save<- c(c,sub, ID)
Track <- rbind(Track, save)
}
}
}
# Record the individuals as captured
Track <- NULL #initialize an empty object with 'CAM <- NULL' and rbind sub to that object
for(m in 1:nrow(Pop)){  # the first loop (m in 1:nrow(pop)) loops over each individual in your dataset, and for each individual, the second loop (n in 1:nrow(CAM)) loops over the camera locations stored in CAM to see if any camera locations match the individual's location (the sub <- ... line)
for(n in 1:nrow(CAM)){ #for the number of cameras in a cell
sub <- CAM[CAM[n,2] == pop[m,2] & CAM[n,3] == pop[m,3],]  #to see if any camera locations match the individual's location (the sub <- ... line)
if(nrow(sub) > 0){ #if there's at least one match (nrow(sub) > 0 ), then you can store the information...
ID = pop[m,1] #store somewhere that this individual was captured,you could do something similar as with CAM, where you initialize an empty object with 'OUT <- NULL' and rbind sub to that object
save<- c(m,n,sub, ID)
Track <- rbind(Track, save)
}
}
}
Pop = function(numindiv, landscape){
#how far apart should individuals be, at max?
#variance = 25 #values is in cells
#initialize pop object
pop = matrix(nrow=100, ncol=100)
#choose rough starting coordinates
x = sample(1:(landscape), 1)
y = sample(1:(landscape), 1)
#set starting locations with set variance from x,y selected above
pop[,1]  = x + rpois(numindiv, variance)
pop[,2]  = y + rpois(numindiv, variance)
return(pop)
}
Pop = function(numindiv, landscape){
#how far apart should individuals be, at max?
#variance = 25 #values is in cells
#initialize pop object
pop = matrix(nrow=100, ncol=100)
#choose rough starting coordinates
x = sample(1:(landscape), 1)
y = sample(1:(landscape), 1)
#set starting locations with set variance from x,y selected above
pop[,1]  = x + rpois(numindiv) # this is what is used to be pop[,1]  = x + rpois(numindiv, variance)
pop[,2]  = y + rpois(numindiv)
return(pop)
}
# Record the individuals as captured
Track <- NULL #initialize an empty object with 'CAM <- NULL' and rbind sub to that object
for(m in 1:nrow(Pop)){  # the first loop (m in 1:nrow(pop)) loops over each individual in your dataset, and for each individual, the second loop (n in 1:nrow(CAM)) loops over the camera locations stored in CAM to see if any camera locations match the individual's location (the sub <- ... line)
for(n in 1:nrow(CAM)){ #for the number of cameras in a cell
sub <- CAM[CAM[n,2] == pop[m,2] & CAM[n,3] == pop[m,3],]  #to see if any camera locations match the individual's location (the sub <- ... line)
if(nrow(sub) > 0){ #if there's at least one match (nrow(sub) > 0 ), then you can store the information...
ID = pop[m,1] #store somewhere that this individual was captured,you could do something similar as with CAM, where you initialize an empty object with 'OUT <- NULL' and rbind sub to that object
save<- c(m,n,sub, ID)
Track <- rbind(Track, save)
}
}
}
LandscapeInit = function(landscape){
#set up object
land  = matrix(nrow=landscape, ncol=landscape)
#return land object
return(land)
}
Move=function(landscape,numindiv,numsteps,move,numcamera){
mvmt = numindiv[1] #x==1, y==2
for(s in 1:numsteps){
cxpos = mvmt[(length(mvmt)-1)]
cypos = mvmt[length(mvmt)]
#determine if indiv will move randomly or will move to next cell
movenext = sample(x=c(0,1), size=1, prob=c((1-move), move))
#random movement to adjacent cell/patch
if(movenext==0){
xpos = sample(c(-1,0,1), 1) + cxpos
ypos = sample(c(-1,0,1), 1) + cypos
}
#move to next cell if
if(movenext==1){
#find next cell
nxtcell = which(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)] == max(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)]), arr.ind = TRUE)
#calculate new position (x and y values)
if(nxtcell[1]==1){xpos = cxpos - 1 }
if(nxtcell[1]==2){xpos = cxpos }
if(nxtcell[1]==3){xpos = cxpos + 1 }
if(nxtcell[2]==1){ypos = cypos - 1 }
if(nxtcell[2]==2){ypos = cypos }
if(nxtcell[2]==3){ypos = cypos + 1 }
#record new position
mvmt = c(mvmt, xpos, ypos)
#check to see if individual is at peak; if yes individual remains in same position
##if(land[xpos,ypos]>=landscape[2]){
#fill out remaining positions
#mvmt=c(mvmt, rep(c(xpos, ypos), (nsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
#check to see if individual is at edge of landscape; if yes individual remains in same position
if(xpos>=(landscape-1) | ypos>=(landscape-1) | xpos<=1 | ypos<=1){
#fill out remaining positions
mvmt=c(mvmt, rep(c(xpos, ypos), (numsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
}
return(mvmt)
}
# Record the individuals as captured
Track <- NULL #initialize an empty object with 'CAM <- NULL' and rbind sub to that object
for(m in 1:nrow(Pop)){  # the first loop (m in 1:nrow(pop)) loops over each individual in your dataset, and for each individual, the second loop (n in 1:nrow(CAM)) loops over the camera locations stored in CAM to see if any camera locations match the individual's location (the sub <- ... line)
for(n in 1:nrow(CAM)){ #for the number of cameras in a cell
sub <- CAM[CAM[n,2] == pop[m,2] & CAM[n,3] == pop[m,3],]  #to see if any camera locations match the individual's location (the sub <- ... line)
if(nrow(sub) > 0){ #if there's at least one match (nrow(sub) > 0 ), then you can store the information...
ID = pop[m,1] #store somewhere that this individual was captured,you could do something similar as with CAM, where you initialize an empty object with 'OUT <- NULL' and rbind sub to that object
save<- c(m,n,sub, ID)
Track <- rbind(Track, save)
}
}
}
Pop = function(numindiv, landscape){
#how far apart should individuals be, at max?
#variance = 25 #values is in cells
#initialize pop object
pop = matrix(nrow=100, ncol=100)
#choose rough starting coordinates
x = sample(1:(landscape), 1)
y = sample(1:(landscape), 1)
#set starting locations with set variance from x,y selected above
pop[,1]  = x + rpois(numindiv) # this is what is used to be pop[,1]  = x + rpois(numindiv, variance)
pop[,2]  = y + rpois(numindiv)
return(pop)
}
CAM <- NULL #CAM,initialize an empty object with 'CAM <- NULL' and rbind sub to that object
cameras <- function(cams){
for(c in 1:cams){
xloc <- sample(1:nrow(land), 50) #takes a camera x location out of the landscape
yloc <- sample(1:nrow(land), 50) #takes a y location of the camera on landscape
save <- c(c, xloc, yloc)
CAM <- rbind(CAM, save)
}
}
View(cameras)
View(cameras)
# Record the individuals as captured
Track <- NULL #initialize an empty object with 'CAM <- NULL' and rbind sub to that object
for(m in 1:nrow(Pop)){  # the first loop (m in 1:nrow(pop)) loops over each individual in your dataset, and for each individual, the second loop (n in 1:nrow(CAM)) loops over the camera locations stored in CAM to see if any camera locations match the individual's location (the sub <- ... line)
for(n in 1:nrow(CAM)){ #for the number of cameras in a cell
sub <- CAM[CAM[n,2] == pop[m,2] & CAM[n,3] == pop[m,3],]  #to see if any camera locations match the individual's location (the sub <- ... line)
if(nrow(sub) > 0){ #if there's at least one match (nrow(sub) > 0 ), then you can store the information...
ID = pop[m,1] #store somewhere that this individual was captured,you could do something similar as with CAM, where you initialize an empty object with 'OUT <- NULL' and rbind sub to that object
save<- c(m,n,sub, ID)
Track <- rbind(Track, save)
}
}
}
nrow(Pop)
Tracking=function(pop, CAM) {
# Record the individuals as captured
Track <- NULL #initialize an empty object with 'CAM <- NULL' and rbind sub to that object
for(m in 1:nrow(pop)){  # the first loop (m in 1:nrow(pop)) loops over each individual in your dataset, and for each individual, the second loop (n in 1:nrow(CAM)) loops over the camera locations stored in CAM to see if any camera locations match the individual's location (the sub <- ... line)
for(n in 1:nrow(CAM)){ #for the number of cameras in a cell
sub <- CAM[CAM[n,2] == pop[m,2] & CAM[n,3] == pop[m,3],]  #to see if any camera locations match the individual's location (the sub <- ... line)
if(nrow(sub) > 0){ #if there's at least one match (nrow(sub) > 0 ), then you can store the information...
ID = pop[m,1] #store somewhere that this individual was captured,you could do something similar as with CAM, where you initialize an empty object with 'OUT <- NULL' and rbind sub to that object
save<- c(m,n,sub, ID)
Track <- rbind(Track, save)
}
}
}
}
Tracking=function(pop, cams) {
# Record the individuals as captured
Track <- NULL #initialize an empty object with 'CAM <- NULL' and rbind sub to that object
for(m in 1:nrow(pop)){  # the first loop (m in 1:nrow(pop)) loops over each individual in your dataset, and for each individual, the second loop (n in 1:nrow(CAM)) loops over the camera locations stored in CAM to see if any camera locations match the individual's location (the sub <- ... line)
for(n in 1:nrow(CAM)){ #for the number of cameras in a cell
sub <- CAM[CAM[n,2] == pop[m,2] & CAM[n,3] == pop[m,3],]  #to see if any camera locations match the individual's location (the sub <- ... line)
if(nrow(sub) > 0){ #if there's at least one match (nrow(sub) > 0 ), then you can store the information...
ID = pop[m,1] #store somewhere that this individual was captured,you could do something similar as with CAM, where you initialize an empty object with 'OUT <- NULL' and rbind sub to that object
save<- c(m,n,sub, ID)
Track <- rbind(Track, save)
}
}
}
}
nrow(CAM)
CAM <- NULL #CAM,initialize an empty object with 'CAM <- NULL' and rbind sub to that object
cameras <- function(cams){
for(c in 1:cams){
k= 50
xloc <- sample(1:nrow(land), k) #takes a camera x location out of the landscape
yloc <- sample(1:nrow(land), k) #takes a y location of the camera on landscape
save <- c(c, xloc, yloc)
CAM <- rbind(CAM, save)
}
}
Tracking=function(pop, cams) {
# Record the individuals as captured
Track <- NULL #initialize an empty object with 'CAM <- NULL' and rbind sub to that object
for(m in 1:nrow(pop)){  # the first loop (m in 1:nrow(pop)) loops over each individual in your dataset, and for each individual, the second loop (n in 1:nrow(CAM)) loops over the camera locations stored in CAM to see if any camera locations match the individual's location (the sub <- ... line)
for(n in 1:nrow(CAM)){ #for the number of cameras in a cell
sub <- CAM[CAM[n,2] == pop[m,2] & CAM[n,3] == pop[m,3],]  #to see if any camera locations match the individual's location (the sub <- ... line)
if(nrow(sub) > 0){ #if there's at least one match (nrow(sub) > 0 ), then you can store the information...
ID = pop[m,1] #store somewhere that this individual was captured,you could do something similar as with CAM, where you initialize an empty object with 'OUT <- NULL' and rbind sub to that object
save<- c(m,n,sub, ID)
Track <- rbind(Track, save)
}
}
}
}
Tracking=function(pop, CAM) {
# Record the individuals as captured
Track <- NULL #initialize an empty object with 'CAM <- NULL' and rbind sub to that object
for(m in 1:nrow(pop)){  # the first loop (m in 1:nrow(pop)) loops over each individual in your dataset, and for each individual, the second loop (n in 1:nrow(CAM)) loops over the camera locations stored in CAM to see if any camera locations match the individual's location (the sub <- ... line)
for(n in 1:nrow(CAM)){ #for the number of cameras in a cell
sub <- CAM[CAM[n,2] == pop[m,2] & CAM[n,3] == pop[m,3],]  #to see if any camera locations match the individual's location (the sub <- ... line)
if(nrow(sub) > 0){ #if there's at least one match (nrow(sub) > 0 ), then you can store the information...
ID = pop[m,1] #store somewhere that this individual was captured,you could do something similar as with CAM, where you initialize an empty object with 'OUT <- NULL' and rbind sub to that object
save<- c(m,n,sub, ID)
Track <- rbind(Track, save)
}
}
}
}
Tracking=function(pop, CAM) {
# Record the individuals as captured
Track <- NULL #initialize an empty object with 'CAM <- NULL' and rbind sub to that object
for(m in 1:nrow(pop)){  # the first loop (m in 1:nrow(pop)) loops over each individual in your dataset, and for each individual, the second loop (n in 1:nrow(CAM)) loops over the camera locations stored in CAM to see if any camera locations match the individual's location (the sub <- ... line)
for(n in 1:nrow(CAM)){ #for the number of cameras in a cell
sub <- CAM[CAM[n,2] == pop[m,2] & CAM[n,3] == pop[m,3],]  #to see if any camera locations match the individual's location (the sub <- ... line)
if(nrow(sub) > 0){ #if there's at least one match (nrow(sub) > 0 ), then you can store the information...
ID = pop[m,1] #store somewhere that this individual was captured,you could do something similar as with CAM, where you initialize an empty object with 'OUT <- NULL' and rbind sub to that object
save<- c(m,n,sub, ID)
Track <- rbind(Track, save)
}
}
}
}
setwd("~/GitHub/ABM-Course")
#to make sure it is the right place you should do session then set up working directory
directory = getwd()
Tracking=function(pop, CAM) {
# Record the individuals as captured
Track <- NULL #initialize an empty object with 'CAM <- NULL' and rbind sub to that object
for(m in 1:nrow(pop)){  # the first loop (m in 1:nrow(pop)) loops over each individual in your dataset, and for each individual, the second loop (n in 1:nrow(CAM)) loops over the camera locations stored in CAM to see if any camera locations match the individual's location (the sub <- ... line)
for(n in 1:nrow(CAM)){ #for the number of cameras in a cell
sub <- CAM[CAM[n,2] == pop[m,2] & CAM[n,3] == pop[m,3],]  #to see if any camera locations match the individual's location (the sub <- ... line)
if(nrow(sub) > 0){ #if there's at least one match (nrow(sub) > 0 ), then you can store the information...
ID = pop[m,1] #store somewhere that this individual was captured,you could do something similar as with CAM, where you initialize an empty object with 'OUT <- NULL' and rbind sub to that object
save<- c(m,n,sub, ID)
Track <- rbind(Track, save)
}
}
}
}
View(Tracking)
CAM <- NULL #CAM,initialize an empty object with 'CAM <- NULL' and rbind sub to that object
cameras <- function(cams){
for(c in 1:cams){
k= 50
xloc <- sample(1:nrow(land), k) #takes a camera x location out of the landscape
yloc <- sample(1:nrow(land), k) #takes a y location of the camera on landscape
save <- c(c, xloc, yloc)
CAM <- rbind(CAM, save)
}
}
Move=function(landscape,numindiv,numsteps,move,numcamera){
mvmt = numindiv[1] #x==1, y==2
for(s in 1:numsteps){
cxpos = mvmt[(length(mvmt)-1)]
cypos = mvmt[length(mvmt)]
#determine if indiv will move randomly or will move to next cell
movenext = sample(x=c(0,1), size=1, prob=c((1-move), move))
#random movement to adjacent cell/patch
if(movenext==0){
xpos = sample(c(-1,0,1), 1) + cxpos
ypos = sample(c(-1,0,1), 1) + cypos
}
#move to next cell if
if(movenext==1){
#find next cell
nxtcell = which(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)] == max(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)]), arr.ind = TRUE)
#calculate new position (x and y values)
if(nxtcell[1]==1){xpos = cxpos - 1 }
if(nxtcell[1]==2){xpos = cxpos }
if(nxtcell[1]==3){xpos = cxpos + 1 }
if(nxtcell[2]==1){ypos = cypos - 1 }
if(nxtcell[2]==2){ypos = cypos }
if(nxtcell[2]==3){ypos = cypos + 1 }
#record new position
mvmt = c(mvmt, xpos, ypos)
#check to see if individual is at peak; if yes individual remains in same position
##if(land[xpos,ypos]>=landscape[2]){
#fill out remaining positions
#mvmt=c(mvmt, rep(c(xpos, ypos), (nsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
#check to see if individual is at edge of landscape; if yes individual remains in same position
if(xpos>=(landscape-1) | ypos>=(landscape-1) | xpos<=1 | ypos<=1){
#fill out remaining positions
mvmt=c(mvmt, rep(c(xpos, ypos), (numsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
}
return(mvmt)
}
Pop = function(numindiv, landscape){
#how far apart should individuals be, at max?
#variance = 25 #values is in cells
#initialize pop object
pop = matrix(nrow=100, ncol=100)
#choose rough starting coordinates
x = sample(1:(landscape), 1)
y = sample(1:(landscape), 1)
#set starting locations with set variance from x,y selected above
pop[,1]  = x + rpois(numindiv) # this is what is used to be pop[,1]  = x + rpois(numindiv, variance)
pop[,2]  = y + rpois(numindiv)
return(pop)
}
LandscapeInit = function(landscape){
#set up object
land  = matrix(nrow=landscape, ncol=landscape)
#return land object
return(land)
}
#Set working directory, import packages, source functions,
setwd("~/GitHub/ABM-Course/Source")    # set temp working directory
#source functions
source(paste(getwd(), "/Landscape.R", sep = ''))
source(paste(getwd(), "/POP.R", sep = ''))
source(paste(getwd(), "/Move.R", sep = ''))
source(paste(getwd(), "/Camera.R", sep = ''))
source(paste(getwd(), "/Tracking.R", sep = ''))
setwd("~/GitHub/ABM-Course")
#to make sure it is the right place you should do session then set up working directory
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
landscape = 100
numindiv= 10  #start off with a number of individuals
numsteps= 1 #number of steps individuals will take
numreps= 5  #
move = 5   #Likelihood of individuals moving to the next cell
numcamera = 50
parameters= expand.grid(landscape,numindiv,numsteps,move,numcamera) #this creates data frame for combination of variables
colnames(parameters) = c("landscape","numindiv","numsteps","move","numcamera")
for(p in 1:nrow(parameters)){
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
numsteps    = parameters$numsteps[p]
move      = parameters$move[p]
numcamera = parameters$numcamera[p]
#initialize landscape
land = LandscapeInit(landscape)
#image(land)
#initialize individuals on landscape
pop = Pop(numindiv, landscape) #
#place cameras on landscape
cam = cameras(cams)
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
numindiv = pop[i,,drop=FALSE]
#the i means iterates
#####     #chart movement
movepath = Move(landscape,numindiv,numsteps,move,numcamera)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/100, movepath[seq(2,length(movepath), 2)]/100, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
}
View(land)
View(parameters)
setwd("~/GitHub/ABM-Course")
#to make sure it is the right place you should do session then set up working directory
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
landscape = 100
numindiv= 10  #start off with a number of individuals
numsteps= 1 #number of steps individuals will take
numreps= 5  #
move = 5   #Likelihood of individuals moving to the next cell
numcamera = 50
parameters= expand.grid(landscape,numindiv,numsteps,move,numcamera) #this creates data frame for combination of variables
colnames(parameters) = c("landscape","numindiv","numsteps","move","numcamera")
for(p in 1:nrow(parameters)){
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
numsteps    = parameters$numsteps[p]
move      = parameters$move[p]
numcamera = parameters$numcamera[p]
#initialize landscape
land = LandscapeInit(landscape)
image(land)
pop = Pop(numindiv, landscape) #
cam = cameras(cams)
1:cams
cams
CAM <- NULL #CAM,initialize an empty object with 'CAM <- NULL' and rbind sub to that object
cameras <- function(numcamera){
for(c in 1:numcamera){
#k=50
xloc <- sample(1:nrow(land), numcamera) #takes a camera x location out of the landscape
yloc <- sample(1:nrow(land), numcamera) #takes a y location of the camera on landscape
save <- c(c, xloc, yloc)
CAM <- rbind(CAM, save)
}
}
View(land)
View(pop)
cam = cameras(numcamera)
#allow individuals to move within landscape
move= Move(landscape,numindiv,numsteps,move,numcamera)
land = LandscapeInit(landscape)
pop = Pop(numindiv, landscape)
cam = cameras(numcamera)
#allow individuals to move within landscape
pathways = NULL
View(land)
View(parameters)
View(pop)
for(i in 1:nrow(pop)){
#isolate individual of interest
numindiv = pop[i,,drop=FALSE]
#the i means iterates
movepath = Move(landscape,numindiv,numsteps,move,numcamera)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/100, movepath[seq(2,length(movepath), 2)]/100, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
