#plot movement
lines(movepath[seq(1,length(movepath), 2)]/100, movepath[seq(2,length(movepath), 2)]/100, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
}
#this would also go in the function part
# =========   The reflecting boundary is added below
for(i in 1:numindiv){           # For each individual i in the array
if(numindiv[i, xpos] > xmax){       # If it moved passed the maximum xloc
numindiv[i, xpos] <- xmax - 1;    # Then move it back toward the center
}
if(numindiv[i, xpos] < 1){          # If it moved below 1 on xloc
numindiv[i, xpos] <- 2;           # Move it toward the centre (2)
}
if(numindiv[i, ypos] > ymax){         # If it moved passed the maximum yloc
numindiv[i, ypos] <- ymax - 1;      # Then move it back toward the centre
}
if(numindiv[i, ypos] < 1){            # If it moved below 1 on yloc
inds[i, ypos] <- 2;             # Then move it toward the centre (2)
}
return(numindiv);
}
landscape = 100
numindiv= 1  #start off with a number of individuals
numsteps= 1 #number of steps individuals will take
numreps= 5  #
move = 10   #Likelihood of individuals moving to the next cell
numcamera = 50
parameters= expand.grid(landscape,numindiv,numsteps,move,numcamera) #this creates data frame for combination of variables
colnames(parameters) = c("landscape","numindiv","numsteps","move","numcamera")
for(p in 1:nrow(parameters)){
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
numsteps    = parameters$nsteps[p]
move      = parameters$move[p]
numcamera = parameters$numcamera[p]
#initialize individuals on landscape
pop = Pop(numindiv, landscape)
#points(Pop[,1]/100, Pop[,2]/100, pch=21, cex=0.5)
#pop = rbind(pop,NewPop(nindv,landscape)) #this will add the different NewPops together
#plot(-100,-100, xlim=c(0,100), ylim=c(0,100))  #this puts the points on its own figure (note 0-100 axes)
#points(pop[,1], pop[,2], pch=19, cex=0.5) #puts points on own fig
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#the i means iterates
#####     #chart movement
movepath = Move(landscape,numindiv,numsteps,move,numcamera)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/100, movepath[seq(2,length(movepath), 2)]/100, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
}
#this would also go in the function part
# =========   The reflecting boundary is added below
for(i in 1:numindiv){           # For each individual i in the array
if(numindiv[i, xpos] > xmax){       # If it moved passed the maximum xloc
numindiv[i, xpos] <- xmax - 1;    # Then move it back toward the center
}
if(numindiv[i, xpos] < 1){          # If it moved below 1 on xloc
numindiv[i, xpos] <- 2;           # Move it toward the centre (2)
}
if(numindiv[i, ypos] > ymax){         # If it moved passed the maximum yloc
numindiv[i, ypos] <- ymax - 1;      # Then move it back toward the centre
}
if(numindiv[i, ypos] < 1){            # If it moved below 1 on yloc
inds[i, ypos] <- 2;             # Then move it toward the centre (2)
}
return(numindiv);
}
#============================================
#camera stations placement?
#============================================
cameras <- function(cams, inds, xcol = 2, ycol = 3, rcol = 4, dcol = 5){
cameras   <- dim(cams)[1]; # camera number
for(c in 1:cameras){       # For each camera (c) in the array
xloc   <- pred[p, xcol]; # Get the x and y locations
yloc   <- pred[p, ycol];
numindiv <- sum( inds[, xcol] == xloc & inds[, ycol] == yloc);
#=======================================
#tracking of individual
#=======================================
if(numindiv > 0){ # If there is an individual, capture them
sampled <- which( inds[, xcol] == xloc & inds[, ycol] == yloc);
if(numindiv < 0){ # But if less than 0 no capture
sampled <- sample(x = numindiv, size = 0, replace = FALSE);
}
numindiv[sampled, dcol] <- 1; # Record the individuals as captured
}
}
# Now need to return *both* the sampled and individuals arrays
samp_indiv <- list(sampled = sampled, numindiv = numindiv);
return(samp_indiv);
}
View(indv)
View(parameters)
View(pop)
View(indv)
landscape = 100
numindiv= 10  #start off with a number of individuals
numsteps= 1 #number of steps individuals will take
numreps= 5  #
move = 10   #Likelihood of individuals moving to the next cell
numcamera = 50
parameters= expand.grid(landscape,numindiv,numsteps,move,numcamera) #this creates data frame for combination of variables
colnames(parameters) = c("landscape","numindiv","numsteps","move","numcamera")
for(p in 1:nrow(parameters)){
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
numsteps    = parameters$nsteps[p]
move      = parameters$move[p]
numcamera = parameters$numcamera[p]
#initialize individuals on landscape
pop = Pop(numindiv, landscape)
#points(Pop[,1]/100, Pop[,2]/100, pch=21, cex=0.5)
#pop = rbind(pop,NewPop(nindv,landscape)) #this will add the different NewPops together
#plot(-100,-100, xlim=c(0,100), ylim=c(0,100))  #this puts the points on its own figure (note 0-100 axes)
#points(pop[,1], pop[,2], pch=19, cex=0.5) #puts points on own fig
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#the i means iterates
#####     #chart movement
movepath = Move(landscape,numindiv,numsteps,move,numcamera)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/100, movepath[seq(2,length(movepath), 2)]/100, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
}
Move=function(landscape,numindiv,numsteps,move,numcamera){
mvmt = numindiv[1] #x==1, y==2
for(s in 1:numsteps){
cxpos = mvmt[(length(mvmt)-1)]
cypos = mvmt[length(mvmt)]
#determine if indiv will move randomly or will move to next cell
movehigh = sample(x=c(0,1), size=1, prob=c((1-move), move))
#random movement to adjacent cell/patch
if(movehigh==0){
xpos = sample(c(-1,0,1), 1) + cxpos
ypos = sample(c(-1,0,1), 1) + cypos
}
#move to higher elevation, added the 'else' here instead of 'if'
if(movehigh==1){
#find highest elevation cell
highpt = which(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)] == max(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)]), arr.ind = TRUE)
#calculate new position (x and y values)
if(highpt[1]==1){xpos = cxpos - 1 }
if(highpt[1]==2){xpos = cxpos }
if(highpt[1]==3){xpos = cxpos + 1 }
if(highpt[2]==1){ypos = cypos - 1 }
if(highpt[2]==2){ypos = cypos }
if(highpt[2]==3){ypos = cypos + 1 }
}
#record new position
mvmt = c(mvmt, xpos, ypos)
#check to see if individual is at peak; if yes individual remains in same position
if(land[xpos,ypos]>=elevation[2]){
#fill out remaining positions
mvmt=c(mvmt, rep(c(xpos, ypos), (nsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
#check to see if individual is at edge of landscape; if yes individual remains in same position
if(xpos>=(landscape-1) | ypos>=(landscape-1) | xpos<=1 | ypos<=1){
#fill out remaining positions
mvmt=c(mvmt, rep(c(xpos, ypos), (numsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
}
return(mvmt)
}
setwd("~/GitHub/ABM-Course")
#to make sure it is the right place you should do session then set up working directory
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
landscape = 100
numindiv= 10  #start off with a number of individuals
numsteps= 1 #number of steps individuals will take
numreps= 5  #
move = 10   #Likelihood of individuals moving to the next cell
numcamera = 50
parameters= expand.grid(landscape,numindiv,numsteps,move,numcamera) #this creates data frame for combination of variables
colnames(parameters) = c("landscape","numindiv","numsteps","move","numcamera")
for(p in 1:nrow(parameters)){
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
numsteps    = parameters$nsteps[p]
move      = parameters$move[p]
numcamera = parameters$numcamera[p]
#initialize individuals on landscape
pop = Pop(numindiv, landscape)
#points(Pop[,1]/100, Pop[,2]/100, pch=21, cex=0.5)
#pop = rbind(pop,NewPop(nindv,landscape)) #this will add the different NewPops together
#plot(-100,-100, xlim=c(0,100), ylim=c(0,100))  #this puts the points on its own figure (note 0-100 axes)
#points(pop[,1], pop[,2], pch=19, cex=0.5) #puts points on own fig
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#the i means iterates
#####     #chart movement
movepath = Move(landscape,numindiv,numsteps,move,numcamera)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/100, movepath[seq(2,length(movepath), 2)]/100, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
}
numsteps
#isolate individual of interest
numindiv = pop[i,,drop=FALSE]
#####     #chart movement
movepath = Move(landscape,numindiv,numsteps,move,numcamera)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/100, movepath[seq(2,length(movepath), 2)]/100, lwd=2)
movepath
#####     #chart movement
movepath = Move(landscape,numindiv,numsteps,move,numcamera)
landscape = 100
numindiv= 10  #start off with a number of individuals
numsteps= 1 #number of steps individuals will take
numreps= 5  #
move = 10   #Likelihood of individuals moving to the next cell
numcamera = 50
parameters= expand.grid(landscape,numindiv,numsteps,move,numcamera) #this creates data frame for combination of variables
colnames(parameters) = c("landscape","numindiv","numsteps","move","numcamera")
for(p in 1:nrow(parameters)){
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
numsteps    = parameters$nsteps[p]
move      = parameters$move[p]
numcamera = parameters$numcamera[p]
#initialize individuals on landscape
pop = Pop(numindiv, landscape)
#points(Pop[,1]/100, Pop[,2]/100, pch=21, cex=0.5)
#pop = rbind(pop,NewPop(nindv,landscape)) #this will add the different NewPops together
#plot(-100,-100, xlim=c(0,100), ylim=c(0,100))  #this puts the points on its own figure (note 0-100 axes)
#points(pop[,1], pop[,2], pch=19, cex=0.5) #puts points on own fig
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
numindiv = pop[i,,drop=FALSE]
#the i means iterates
#####     #chart movement
movepath = Move(landscape,numindiv,numsteps,move,numcamera)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/100, movepath[seq(2,length(movepath), 2)]/100, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
}
numsteps
parameters$nsteps[p]
setwd("~/GitHub/ABM-Course")
#to make sure it is the right place you should do session then set up working directory
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
landscape = 100
numindiv= 10  #start off with a number of individuals
numsteps= 1 #number of steps individuals will take
numreps= 5  #
move = 10   #Likelihood of individuals moving to the next cell
numcamera = 50
parameters= expand.grid(landscape,numindiv,numsteps,move,numcamera) #this creates data frame for combination of variables
colnames(parameters) = c("landscape","numindiv","numsteps","move","numcamera")
for(p in 1:nrow(parameters)){
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
numsteps    = parameters$numsteps[p]
move      = parameters$move[p]
numcamera = parameters$numcamera[p]
#initialize individuals on landscape
pop = Pop(numindiv, landscape)
#points(Pop[,1]/100, Pop[,2]/100, pch=21, cex=0.5)
#pop = rbind(pop,NewPop(nindv,landscape)) #this will add the different NewPops together
#plot(-100,-100, xlim=c(0,100), ylim=c(0,100))  #this puts the points on its own figure (note 0-100 axes)
#points(pop[,1], pop[,2], pch=19, cex=0.5) #puts points on own fig
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
numindiv = pop[i,,drop=FALSE]
#the i means iterates
#####     #chart movement
movepath = Move(landscape,numindiv,numsteps,move,numcamera)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/100, movepath[seq(2,length(movepath), 2)]/100, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
}
for(p in 1:nrow(parameters)){
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
numsteps    = parameters$numsteps[p]
move      = parameters$move[p]
numcamera = parameters$numcamera[p]
#initialize individuals on landscape
pop = Pop(numindiv, landscape)
#points(Pop[,1]/100, Pop[,2]/100, pch=21, cex=0.5)
#pop = rbind(pop,NewPop(nindv,landscape)) #this will add the different NewPops together
#plot(-100,-100, xlim=c(0,100), ylim=c(0,100))  #this puts the points on its own figure (note 0-100 axes)
#points(pop[,1], pop[,2], pch=19, cex=0.5) #puts points on own fig
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
numindiv = pop[i,,drop=FALSE]
#the i means iterates
#####     #chart movement
movepath = Move(landscape,numindiv,numsteps,move,numcamera)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/100, movepath[seq(2,length(movepath), 2)]/100, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
}
#####     #chart movement
movepath = Move(landscape,numindiv,numsteps,move,numcamera)
View(indv)
View(numindiv)
Pop = function(numindiv, landscape){
#how far apart should individuals be, at max?
variance = 25 #values is in cells
#initialize pop object
pop = matrix(nrow=100, ncol=100)
#choose rough starting coordinates
x = sample(1:(landscape-variance), 1)
y = sample(1:(landscape-variance), 1)
#set starting locations with set variance from x,y selected above
pop[,1]  = x + rnorm(numindiv, variance)
pop[,2]  = y + rnorm(numindiv, variance)
return(pop)
}
View(Pop)
LandscapeInit = function(landscape){
#set up object
land  = matrix(nrow=landscape, ncol=landscape)
#work from edges and fill in elevation; similar to above but can now do entire columns at one time
#for(r in (xpeak-1):1){
# land[r,] = land[(r+1),] - round(rnorm(landscape, 5, 2), 0)
# }
# for(r in (xpeak+1):landscape){
#  land[r,] = land[(r-1),] - round(rnorm(landscape, 5, 2), 0)
#}
#return land object
return(land)
}
Move=function(landscape,numindiv,numsteps,move,numcamera){
mvmt = numindiv[1] #x==1, y==2
for(s in 1:numsteps){
cxpos = mvmt[(length(mvmt)-1)]
cypos = mvmt[length(mvmt)]
#determine if indiv will move randomly or will move to next cell
movehigh = sample(x=c(0,1), size=1, prob=c((1-move), move))
#random movement to adjacent cell/patch
if(movehigh==0){
xpos = sample(c(-1,0,1), 1) + cxpos
ypos = sample(c(-1,0,1), 1) + cypos
}
#move to higher elevation, added the 'else' here instead of 'if'
if(movehigh==1){
#find highest elevation cell
highpt = which(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)] == max(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)]), arr.ind = TRUE)
#calculate new position (x and y values)
if(highpt[1]==1){xpos = cxpos - 1 }
if(highpt[1]==2){xpos = cxpos }
if(highpt[1]==3){xpos = cxpos + 1 }
if(highpt[2]==1){ypos = cypos - 1 }
if(highpt[2]==2){ypos = cypos }
if(highpt[2]==3){ypos = cypos + 1 }
}
#record new position
mvmt = c(mvmt, xpos, ypos)
#check to see if individual is at peak; if yes individual remains in same position
if(land[xpos,ypos]>=elevation[2]){
#fill out remaining positions
mvmt=c(mvmt, rep(c(xpos, ypos), (nsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
#check to see if individual is at edge of landscape; if yes individual remains in same position
if(xpos>=(landscape-1) | ypos>=(landscape-1) | xpos<=1 | ypos<=1){
#fill out remaining positions
mvmt=c(mvmt, rep(c(xpos, ypos), (numsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
}
return(mvmt)
}
#Set working directory, import packages, source functions,
setwd("~/GitHub/ABM-Course/Source")    # set temp working directory
setwd("~/GitHub/ABM-Course")
#to make sure it is the right place you should do session then set up working directory
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
landscape = 100
numindiv= 10  #start off with a number of individuals
numsteps= 1 #number of steps individuals will take
numreps= 5  #
move = 10   #Likelihood of individuals moving to the next cell
numcamera = 50
parameters= expand.grid(landscape,numindiv,numsteps,move,numcamera) #this creates data frame for combination of variables
colnames(parameters) = c("landscape","numindiv","numsteps","move","numcamera")
for(p in 1:nrow(parameters)){
landscape = parameters$landscape[p]
numindiv  = parameters$numindiv[p]
numsteps    = parameters$numsteps[p]
move      = parameters$move[p]
numcamera = parameters$numcamera[p]
#initialize individuals on landscape
pop = Pop(numindiv, landscape)
#points(Pop[,1]/100, Pop[,2]/100, pch=21, cex=0.5)
#pop = rbind(pop,NewPop(nindv,landscape)) #this will add the different NewPops together
#plot(-100,-100, xlim=c(0,100), ylim=c(0,100))  #this puts the points on its own figure (note 0-100 axes)
#points(pop[,1], pop[,2], pch=19, cex=0.5) #puts points on own fig
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
numindiv = pop[i,,drop=FALSE]
#the i means iterates
#####     #chart movement
movepath = Move(landscape,numindiv,numsteps,move,numcamera)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/100, movepath[seq(2,length(movepath), 2)]/100, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
}
#this would also go in the function part
# =========   The reflecting boundary is added below
for(i in 1:numindiv){           # For each individual i in the array
if(numindiv[i, xpos] > xmax){       # If it moved passed the maximum xloc
numindiv[i, xpos] <- xmax - 1;    # Then move it back toward the center
}
if(numindiv[i, xpos] < 1){          # If it moved below 1 on xloc
numindiv[i, xpos] <- 2;           # Move it toward the centre (2)
}
if(numindiv[i, ypos] > ymax){         # If it moved passed the maximum yloc
numindiv[i, ypos] <- ymax - 1;      # Then move it back toward the centre
}
if(numindiv[i, ypos] < 1){            # If it moved below 1 on yloc
numindiv[i, ypos] <- 2;             # Then move it toward the centre (2)
}
return(numindiv);
}
#####     #chart movement
movepath = Move(landscape,numindiv,numsteps,move,numcamera)
View(parameters)
View(numindiv)
View(numindiv)
View(parameters)
View(numindiv)
Move=function(landscape,numindiv,numsteps,move,numcamera){
mvmt = numindiv[1] #x==1, y==2
for(s in 1:numsteps){
cxpos = mvmt[(length(mvmt)-1)]
cypos = mvmt[length(mvmt)]
#determine if indiv will move randomly or will move to next cell
movehigh = sample(x=c(0,1), size=1, prob=c((1-move), move))
#random movement to adjacent cell/patch
if(movehigh==0){
xpos = sample(c(-1,0,1), 1) + cxpos
ypos = sample(c(-1,0,1), 1) + cypos
}
#move to higher elevation, added the 'else' here instead of 'if'
if(movehigh==1){
#find highest elevation cell
highpt = which(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)] == max(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)]), arr.ind = TRUE)
#calculate new position (x and y values)
if(highpt[1]==1){xpos = cxpos - 1 }
if(highpt[1]==2){xpos = cxpos }
if(highpt[1]==3){xpos = cxpos + 1 }
if(highpt[2]==1){ypos = cypos - 1 }
if(highpt[2]==2){ypos = cypos }
if(highpt[2]==3){ypos = cypos + 1 }
}
#record new position
mvmt = c(mvmt, xpos, ypos)
#check to see if individual is at peak; if yes individual remains in same position
if(land[xpos,ypos]>=elevation[2]){
#fill out remaining positions
mvmt=c(mvmt, rep(c(xpos, ypos), (nsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
#check to see if individual is at edge of landscape; if yes individual remains in same position
if(xpos>=(landscape-1) | ypos>=(landscape-1) | xpos<=1 | ypos<=1){
#fill out remaining positions
mvmt=c(mvmt, rep(c(xpos, ypos), (numsteps-((length(mvmt)/2)-1))))
#exit loop
break
}
}
return(mvmt)
}
gc()
